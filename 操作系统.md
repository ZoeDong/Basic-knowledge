云架构平台部 机器学习平台
franklan@tencent.com

# 操作系统

## 内存管理
  1. 块式管理：
   主存分为一块块，大小固定。当所需的程序片断不在主存时就分配一块主存空间，把程序片断load入主存，就算所需的程序片度只有几个字节也只能把这一块分配给它。这样会造成很大的浪费，平均浪费了50％的内存空间，但是易于管理。
  2. 页式管理：
   主存分为一页页的，每一页的空间要比一块的空间小很多，空间利用率要比块式管理高很多。
  3. 段式管理
   主存分为一段段的，每一段的空间又要比一页的空间小很多，在空间利用率上又比页式管理高很多。但是也有另外一个缺点。一个程序片断可能会被分为几十段，这样很多时间就会被浪费在计算每一段的物理地址上。
  4. 段页式管理（常用）
   结合了段式管理和页式管理的优点。将程序分成若干段，每个段分成若干页。段页式管理每取一数据，要访问3次内存。

  - 分页和分段有什么区别
    **段式存储管理：**
    一种**符合用户视角的内存分配管理方案**。在段式存储管理中，将程序的地址空间划分为若干段（segment），如代码段，数据段，堆栈段；这样每个进程有一个二维地址空间，相互独立，互不干扰。
    **优点：**
    没有内碎片（因为段大小可变，改变段大小来消除内碎片）。但段换入换出时，会产生外碎片（比如4k的段换5k的段，会产生1k的外碎片）<p>
    **页式存储管理:**
    一种**用户视角内存与物理内存相分离的内存分配管理方案**。在页式存储管理中，将程序的逻辑地址划分为**固定大小的页（page）**，而物理内存划分为**同样大小的帧**，程序加载时，**可以将任意一页放入内存中任意一个帧**，这些帧不必连续，从而实现了离散分配。
    **优点：**
    没有外碎片（因为页的大小固定），但会产生内碎片（一个页可能填充不满）。<p>
    **两者的不同点：**
    1. 目的不同：分页是由于系统管理的需要而不是用户的需要，它是信息的物理单位；分段的目的是为了能更好地满足用户的需要，它是信息的逻辑单位，它含有一组其意义相对完整的信息；
    2. 大小不同：页的大小固定且由系统决定，而段的长度却不固定，由其所完成的功能决定； 
    3. 地址空间不同： 段向用户提供**二维地址空间**；页向用户提供的是一维地址空间；
    4. 信息共享：段是信息的逻辑单位，便于存储保护和信息的共享，页的保护和共享受到限制；
    5. 内存碎片：页式存储管理的优点是没有外碎片（因为页的大小固定），但会产生内碎片（一个页可能填充不满）；而段式管理的优点是没有内碎片（因为段大小可变，改变段大小来消除内碎片）。但段换入换出时，会产生外碎片（比如4k的段换5k的段，会产生1k的外碎片）。

## ~~进程/线程~~
### 进程同步
#### 1. 临界区
* 对临界资源进行访问的那段代码称为临界区。
* 为了互斥访问临界资源，每个进程在进入临界区之前，需要先进行检查。
```
// entry section
// critical section;
// exit section
```
#### 2. 同步与互斥
* 同步：多个进程因为合作产生的直接制约关系，使得进程有一定的先后执行关系。
* 互斥：多个进程在同一时刻只有一个进程能进入临界区。

#### 3. 信号量
* 信号量（Semaphore）是一个整型变量，可以对其执行 down 和 up 操作，也就是常见的 P 和 V 操作。
* down : 如果信号量大于 0 ，执行 -1 操作；如果信号量等于 0，进程睡眠，等待信号量大于 0；
* up ：对信号量执行 +1 操作，唤醒睡眠的进程让其完成 down 操作。
* down 和 up 操作需要被设计成原语，不可分割，通常的做法是在执行这些操作的时候屏蔽中断。
* 如果信号量的取值只能为 0 或者 1，那么就成为了 互斥量（Mutex） ，0 表示临界区已经加锁，1 表示临界区解锁。

#### 4. 管程
* 使用信号量机制实现的生产者消费者问题需要客户端代码做很多控制，而管程把控制的代码独立出来，不仅不容易出错，也使得客户端代码调用更容易。
* c 语言不支持管程
* 管程有一个重要特性：在一个时刻只能有一个进程使用管程。进程在无法继续执行的时候不能一直占用管程，否则其它进程永远不能使用管程。
* 管程引入了 条件变量 以及相关的操作：wait() 和 signal() 来实现同步操作。对条件变量执行 wait() 操作会导致调用进程阻塞，把管程让出来给另一个进程持有。signal() 操作用于唤醒被阻塞的进程。

### 进程间通信
进程同步与进程通信很容易混淆，它们的区别在于：
* 进程同步：控制多个进程按一定顺序执行；
* 进程通信：进程间传输信息。
* 进程通信是一种手段，而进程同步是一种目的。也可以说，为了能够达到进程同步的目的，需要让进程进行通信，传输一些进程同步所需要的信息。

### 1. 管道
* 管道是通过调用 pipe 函数创建的，fd[0] 用于读，fd[1] 用于写。
```C++
#include <unistd.h>
int pipe(int fd[2]);
```
* 它具有以下限制：
  * 只支持**半双工**通信（单向交替传输）；
  * 只能在**父子进程**或者**兄弟进程**中使用。

### 2. 命名管道/FIFO
* 也称为命名管道，**去除了管道只能在父子进程中使用的限制**。
```C++
#include <sys/stat.h>
int mkfifo(const char *path, mode_t mode);
int mkfifoat(int fd, const char *path, mode_t mode);
```
* FIFO 常用于客户-服务器应用程序中，FIFO 用作汇聚点，在客户进程和服务器进程之间传递数据。

### 3. 消息队列
相比于 FIFO，消息队列具有以下优点：
* 消息队列可以**独立于读写进程存在**，从而避免了 FIFO 中同步管道的打开和关闭时可能产生的困难；
* 避免了 FIFO 的同步阻塞问题，不需要进程自己提供同步方法；
* 读进程可以根据消息类型有选择地接收消息，而不像 FIFO 那样只能默认地接收。

### 4. 信号量
它是一个**计数器**，用于为多个进程提供对共享数据对象的访问。

### 5. 共享存储
* 允许**多个进程共享一个给定的存储区**。因为数据不需要在进程之间复制，所以这是**最快**的一种 IPC。
* 需要使用**信号量**用来同步对共享存储的访问。
* 多个进程可以将同一个文件映射到它们的地址空间从而实现共享内存。另外 XSI 共享内存不是使用文件，而是使用内存的匿名段。

### 6. 套接字
* 与其它通信机制不同的是，它可用于不同机器间的进程通信。

### 同一个进程内的子线程，堆空间和栈空间分别是共享的还是私有的？
在多线程环境下，每个线程**私有一个栈，一个程序计数器和还有寄存器**
栈和程序计数器用来保存线程的执行历史和线程的执行状态
其他的资源（比如堆、地址空间、全局变量）是由同一个进程内的多个线程共享

### 调度
#### 批处理系统中的调度
批处理系统没有太多的用户操作，在该系统中，调度算法目标是保证吞吐量和周转时间（从提交到终止的时间）。
##### 先来先服务(FCFS)
* 有利于长作业，但不利于短作业
* 短作业等待时间过长
##### 最短作业优先 (SJF) 
* 非抢占式：一旦进程占有CPU，它将一直运行直到CPU用时到达。长作业有可能会饿死，一直等待短作业执行完毕。
* 抢占式：如果一个新来的进程具有更小的CPU用时，则中断当前进程，使新来的进程使用CPU。（比较剩余CPU时间）
* 难点：难以预先知道进程的CPU用时。

#### 交互式系统中的调度
交互式系统有大量的用户交互操作，在该系统中调度算法的目标是快速地进行响应。
##### 时间片轮转调度
* 每一个进程分得一个小的CPU时间片
* 时间片轮转算法的效率和时间片的大小有很大关系：时间片太小，进程切换得频繁；时间片过长，实时性不能得到保证
##### 优先级调度
* SJF实际上也是优先级调度，优先级：预测的下次占用CPU时间。
* 问题：饥饿，低优先级进程可能永远得不到执行。
* 解决方法：年龄，随着时间的增长，进程的优先级增加。
##### 多级队列调度
* 每一个就绪队列赋予一个不同的优先级类
* 从高到低分多个优先级类，每个类依次赋予1.2.4.8.16…个时间片，运行完将进程移到下一个类


## 虚拟内存
**虚拟地址**的前x位表示**页号**，后y位表示**偏移量**
根据页号可以得到**页表**的**索引**，读取页表索引位置的值可以得到**页框号**，页框中有一位表示该页框是否在**物理地址**中
如果在，则根据得到的页框号+偏移量可以得到物理地址
如果不在，将物理地址中最不常用的页框写回磁盘，修改该页框是否在物理地址的标记，将请求的页框写进物理地址，并修改是否在物理地址的标记

## 页面置换
### 1. 最优页面置换算法	
* 替换最远的将来不会用到的页面，通常可以保证获得最低的缺页率
* 不可实现，但可做基准
### 2. LRU(Least Recently Used 最近最久未使用)
* 根据过去使用页面的情况，淘汰最久未被使用的页面
* 为了实现 LRU，需要在内存中维护一个所有页面的链表。当一个页面被访问时，将这个页面移到链表表头。保证链表表尾的页面是最近最久未访问的。
* 每次访问都需要更新链表，因此这种方式实现的 LRU 代价很高。
* 很优秀，但很难实现
### 3. NRU(Not Recently Used 最近未使用)
* 每个页面都有两个状态位：是否访问R与是否修改M
* 当启动一个进程时，所有页面的两个位都由操作系统设置成0；R位被定期地（比如在每次时钟中断时）清零
* 可以将页面分成以下四类：
  第0类：R=0，M=0（未访问、未修改）
  第1类：R=0，M=1（未访问、已被修改）【第3类的R位2被时钟中断清零】
  第2类：R=1，M=0（已被访问、未修改）
  第3类：R=1，M=1（已被访问、已被修改）
* 当发生缺页中断时，NRU 算法**随机**地从类编号最小的非空类中挑选一个页面将它换出。
* NRU 优先换出已经被修改的脏页面（R=0，M=1），而不是被频繁使用的干净页面（R=1，M=0）。
* 非常粗糙
### 4. FIFO
* 选择换出的页面是最先进入的页面。
* 该算法会将那些经常被访问的页面换出，导致**缺页率升高**。

### 5. 第二次机会
* 当页面被访问 (读或写) 时设置该页面的 R 位为 1。
* 需要替换的时候，检查最老页面的 R 位。如果 R=0，那么这个页面既老又没有被使用，可以立刻置换掉；如果R=1移到链表尾，并令R=0，修改它的装入时间使它就像刚装入的一样，然后继续从链表的头部开始搜索。
* 比FIFO有大的改善，避免把经常使用的页面置换出去

### 6. 时钟算法
* 第二次机会算法需要在链表中移动页面，降低了效率。时钟算法使用环形链表将页面连接起来，再使用一个**指针指向最老的页面。**
* 环形链表，现实的

### 7. 工作集算法
* 工作集：进程当前访问的页面集合
* 当发生缺页中断时，淘汰一个不在工作集中的页面。
* 实现起来**开销很大**，每次缺页都需要扫描整个页表

* 法一：
  * 用一个长度为k的移位寄存器，每进行一次内存访问就把寄存器左移一位，然后在最右端插入刚才所访问过的页面号。移位寄存器中的k个页面号的集合就是工作集。
  * 理论上，当缺页中断发生时，只要读出移位寄存器中的内容并排序；然后删除重复的页面。结果就是工作集。
  * 然而，维护移位寄存器并在缺页中断时处理它所需的开销很大，因此该技术从来没有被使用过。

* 法二：
  * 定义工作集是过去tms实际运行时间中的内存访问所用到的页面的集合
  * 当发生缺页中断时，扫描整个页表：
    * 若R=1，设置上次使用时间=当前实际时间
    * 若R=0且生存时间>t，移除页面
    * 若R=0且生存时间<=t，记录生存时间最长的页面；若没有页面可以被淘汰，则淘汰生存时间最长的也没面

### 8. 工作集时钟算法
* 好的有效算法
* 最初，该表是空的当装入第一个页面时，把它加到该表中。随着更多的页面的加入，它们形成一个环。
* 每个表项包含来自基本工作集算法的上次使用时间，以及R(访问)位和M位(修改位，图中由每个表项上面的空白域表示)。
* 当发生缺页中断时，扫描整个页表：
  * 若R=1：置R=0
  * 若R=0，页面是干净且生存时间>t：移除页面，装载新页面
  * 若R=0，页面被修改过：记录干净页面的位置；为了避免写磁盘操作引起的进程切换，指针继续向前走，找到一个旧的并干净的页面
  * 如果指针经过一圈并返回起始点，存在两种情况：
    * 若曾经置R=0，则至少有一个页面可以被置换
    * 若没有置R=0，则随便选择一个干净页面淘汰

# TODO
进程和线程有啥区别
讲一下操作系统，进程，线程，内存，iO，死锁
写一个生产者消费者 https://www.cnblogs.com/kiplove/p/6745335.html



