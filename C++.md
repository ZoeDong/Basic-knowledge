# C++
## 原码 反码 补码
  反码：正数不变；负数符号位不变，其余取反
  补码：正数不变；负数符号位不变，从右往左第一个1之前保留，之后取反/反码+1
## 内存溢出与内存泄露
  两者关系：内存泄露 → 剩余内存不足 → 后续申请不到足够内存 →内存溢出。
  - 内存溢出：申请不到足够的内存；
  - 内存泄露：无法释放已申请的内存；
    - 内存泄露的原因：new创建的对象没有及时delete/delete错误（使用已经释放的对象/同一块内存释放两次）：
      1. 构造函数new创建出来的对象，析构函数没有delete
      2. 释放对象数组时只调用了delete而非delete []：
        导致只有对象数组的第一个对象的析构函数得到执行并回收了内存占用，数组的其他对象所占内存得不到回收
      3. 没有将基类的析构函数定义为虚函数:
        当**基类指针**指向派生类对象时，派生类中有动态分配的内存，如果基类的析构函数不是virtual，那么**派生类的析构函数将不会被调用**，派生类的资源没有正确释放
        ```C++
        Fruit *basket[2]; // 基类指针指向派生类
        basket[0] = new Apple;
        basket[1] = new Banana;
        for (i = 0; i < 2; ++i){
            delete basket[i];
        }
        ```
      4. 对指针/对象进行浅拷贝：
        导致拷贝前后两个对象指向**同一个地址空间**，内存被释放两次；【深浅拷贝】
      5. 在外部函数分配的堆内存，不要在调用函数里面释放，而在外部函数内释放；
      6. ~~delete掉一个void*类型的指针：~~
        导致**没有调用到对象的析构函数**，析构的所有清理工作都没有去执行
      7. ~~没有正确地清除嵌套的对象指针~~
        某个对象以引用语义（指针）了包含另一个对象，而不是以值的方式。
        解决办法：基类/继承类各管各的内存，在构造函数里面分配内存，virtual析构函数各自释放内存
      8. ~~指向对象的指针数组不等同于对象数组:~~
        对象数组:数组中存放的是对象，只需要delete []p，即可调用对象数组中的每个对象的析构函数释放空间；<p>
        指向对象的指针数组是指：数组中存放的是指向对象的指针，不仅要释放每个对象的空间，还要释放每个指针的空间，delete []p只是释放了每个指针，但是并没有释放对象的空间 -> 正确的做法，是通过一个循环，将每个对象释放了，然后再把指针释放了。
    - 内存泄漏避免方法：
      1. new和delete运算符配对使用的习惯，在自由存储空间上动态分配，使用完毕后释放。
      2. 智能指针：智能指针可以自动删除分配的内存。智能指针和普通指针类似，只是不需要手动释放指针，而是通过智能指针自己管理内存的释放。
## 野指针
  指向**被释放**的或者**访问受限内存**的指针。
  造成野指针的原因：
  1. 指针变量**没有初始化**（如果值不定，可以初始化为NULL）
  2. 指针被free或者**delete后，没有置为NULL**, free和delete只是把指针所指向的内存给释放掉，并没有把指针本身干掉，此时指针指向的是“垃圾”内存。释放后的指针应该被置为NULL.
  3. 指针操作**超越了变量的作用范围**，比如返回指向栈内存的指针就是野指针。
## 浅拷贝/位拷贝 与 深拷贝/值拷贝
  - 浅拷贝：**拷贝地址，对指针的拷贝**，拷贝后两个指针指向同一个内存空间 
    问题：
    1. 两个（或两个以上）指针指向同一块空间，内存会被多次释放
    2. 两个对象绑定，一旦一个指针修改了这块空间的值，另一个指针指向的空间的值也会被修改。
  - 深拷贝：**拷贝内容，对指针和指针指向的内容进行拷贝**，拷贝后两个指针指向两个不同地址的指针
    开辟一块新地址空间，将需要拷贝的内容赋值到新地址空间
    改进：引用计数的写时拷贝->引用计数的写时拷贝，读有时也会拷贝
    当对象中存在指针成员时，除了在复制对象时需要考虑**自定义拷贝构造函数**，还应该考虑以下两种情形：
    1. 当函数的参数为对象时，实参传递给形参的实际上是实参的一个拷贝对象，系统自动通过拷贝构造函数实现；
    2. 当函数的返回值为一个对象时，该对象实际上是函数内对象的一个拷贝，用于返回函数调用处。
  参考：https://blog.csdn.net/xu1105775448/article/details/80546950
## 继承——派生类中使用基类private对象
#### 构造函数
- 派生类初始化基类private成员，采用成员初始化列表语法；除非使用没默认构造函数，否则应该显示调用基类构造函数
  ```C++
  BrassPluss::BrassPlus(const string& s, long an, double bal, double ml, double r): Brass(s, an, bal){
    maxLoan=ml;
    owesBank=0.0;
    rate=r;
  }
  ```
- 也可以对派生类成员使用成员初始化列表语法
  ```C++
  BrassPluss::BrassPlus(const string& s, long an, double bal, double ml, double r): Brass(s, an, bal), maxLoan(ml), owesBank(0.0), rate(r){
  }
  ``
#### 非构造函数
调用公有基类方法,使用**作用域解析运算符**来调用基类方法
  ```C++
  void BrassPluss::ViewAcct()const{
    Brass::ViewAcct();// 使用作用域解析运算符来调用基类方法
    cout<<"maxLoan:"<<maxLoan<<endl;
    cout<<"Owed to bank:"<<owesBank<<endl;
    cout<<"Loan Rate:"<<100 * rate<<endl;
  }
  ```
## 继承——派生类对象构造函数初始化顺序
  1. 调用基类中的构造函数（如果有多个基类，根据继承时声明的顺序进行初始化）
  2. 调用成员类中的构造函数（如果有多个成员类，根据其声明的顺序进行初始化）
  3. 初始化派生类本身的构造函数
  ```C++
  class A{
  public:A{…}
        ~A{…}
  };

  class B{
  public:B{…}
        ~B{…}
  };

  class D{
  public:D{…}
        ~D{…}
  };

  class E{
  public:E{…}
        ~E{…}
  };

  class C :public A,public B{
  public:C{…}
        ~C{…}
  private:D objD_; 
          E objE_;
  }

  int main(void){   
        C test;   
        return 0;   
  }
  ```  
  构造函数调用的顺序:A{…}、B{…}、D{…}、E{…}、C{…}
## 构造函数 析构函数
### 构造函数
命名必须和类名完全相同
没有返回类型，也不能定义为void
不能被直接（显式）调用，必须通过new运算符在创建对象时自动调用
可以重载
### 析构函数
函数名前加取反符~
对象生命周期结束时，系统自动调用执行
没有返回值、参数、不能重载
如果用户没有写析构函数，编译系统会自动生成一个缺省的析构函数，释放构造函数分配给对象的内存。
### 重载
同名不同参，返回类型可以相同也可以不同；
参数不同：类型，个数，顺序
### 运算符重载
带有特殊名称的函数，函数名是由关键字operator 和其后要重载的运算符符号构成
大多数的重载运算符可被定义为**普通的非成员函数**或者被定义为**类成员函数**
```C++
Box operator+(const Box&);//类成员函数
Box operator+(const Box&, const Box&);//类的非成员函数
```
## & *
取地址运算符&
间接寻址运算符*：返回操作数所指定地址的变量的值
```C++
int a = 123;
int* p = &a;
cout << &a << endl; //0x00b7fea0 {123}	int*
cout << p << endl;  //0x00b7fea0 {123}	int*
cout << *p << endl; //123	int 
cout << &p << endl; //0x00b7fe94 {0x00b7fea0 {123}}	int ** [在内存中也有一个地址储存变量p]
```
## null nullptr 
- NULL在C++中就是0，因为在C++中void* 类型是不允许隐式转换成其他类型的
- 之前C++中用0来代表空指针，但是实际上是一个int类型的0
- C++11加入了nullptr，保证在任何情况下都代表空指针
## 空悬指针
- delete之后，指针就变成了空悬指针，即**指向**一块曾经保存数据对象但现在**已经无效的内存的地址**，编译器**只会释放该指针所指向的内存空间并回收**，之后可以分配给新开辟的空间，而**不会删除这个指针本身**
- 避免悬空指针的问题：在指针即将要离开其作用域之前释放掉它所关联的内存，使得指针不指向任何对象
- 否则若之后定义一个指针，将之前释放掉的内存空间分配给他，则两个指针同时指向同一个内存空间
- 因此删除一个指针之后，一定将该指针设置成空指针（delete *p之后一定要加上： p=NULL/p=nullptr）
## map与unordered_map
### 引入头文件不同
map: #include < map >
unordered_map: #include < unordered_map >

### 内部实现机理不同
- map：map内部实现了一个**红黑树**（红黑树是非严格平衡二叉搜索树，而AVL是严格平衡二叉搜索树），红黑树具有自动排序的功能，因此**map内部的所有元素都是有序的**，红黑树的每一个节点都代表着map的一个元素。因此，对于map进行的查找，删除，添加等一系列的操作都相当于是对红黑树进行的操作。map中的元素是按照二叉搜索树（又名二叉查找树、二叉排序树，特点就是左子树上所有节点的键值都小于根节点的键值，右子树所有节点的键值都大于根节点的键值）存储的，使用中序遍历可将键值按照从小到大遍历出来。
- unordered_map: unordered_map内部实现了一个**哈希表**（也叫散列表，通过把关键码值映射到Hash表中一个位置来访问记录，查找的时间复杂度可达到O(1)，其在海量数据处理中有着广泛应用）。因此，其元素的排列顺序是无序的。

### 优缺点以及适用处
- map：
优点：**有序性**，这是map结构最大的优点，其元素的有序性在很多应用中都会简化很多的操作。红黑树，内部实现一个红黑书使得map的很多操作在lgn的时间复杂度下就可以实现，因此**效率非常的高**
缺点：**空间占用率高**，因为map内部实现了红黑树，虽然提高了运行效率，但是因为每一个节点都需要额外保存父节点、孩子节点和红/黑性质，使得每一个节点都占用大量的空间
适用：对于那些**有顺序要求的问题**，用map会更高效一些

- unordered_map：
优点： 因为内部实现了哈希表，因此其**查找速度非常的快**
缺点： 哈希表的**建立比较耗费时间**
适用处：对于**查找问题**，unordered_map会更加高效一些，因此遇到查找问题，常会考虑一下用unordered_map

- 总结：
内存占有率的问题就转化成红黑树 VS hash表 , 还是**unorder_map占用的内存要高**。
但是**unordered_map执行效率**要比map**高**很多

- map和unordered_map的使用
unordered_map的用法和map是一样的，提供了 insert，size，count（计算参数key有几个）等操作，并且里面的元素也是以pair类型来存贮的。其底层实现是完全不同的，但是就外部使用来说却是一致的。
## new / delete 与 malloc / free
- 异同点
  - 相同点：
    - 都可用于内存的动态申请和释放
  - 不同点：
    - 前者是C++运算符，后者是C/C++语言标准库函数
    - new自动计算要分配的空间大小，malloc需要手工计算
    - new是类型安全的，malloc不是。
    - 用malloc分配空间存储类的对象存在风险，因为不会调用构造函数
    - malloc和free是标准库函数，支持**覆盖**；new和delete是运算符，并且支持**重载**。
    - new/delete是保留字,**不需要头文件支持**. malloc/free需要**头文件库函数支持**. 使用malloc/free需要包含 #include<cstdlib> 或<stdlib>
    - new和delete除了**分配回收**功能外，还会**调用构造函数和析构函数**；malloc**仅仅分配内存空间**，free**仅仅回收空间**，不具备调用构造函数和析构函数功能
    - new是**封装了malloc**，直接free不会报错，但是这**只是释放内存，而不会析构对象**
    - malloc和free**返回**的是**void类型指针**（必须进行类型转换），new和delete返回的是**具体类型指针**。

- delete和delete[]区别
delete只会调用一次析构函数。delete[]会调用数组中每个元素的析构函数。

- new和delete是如何实现的
new：首先调用名为operator new的标准库函数，分配足够大的原始为类型化的内存，以保存指定类型的一个对象；接下来运行该类型的一个构造函数，用指定初始化构造对象；最后返回指向新分配并构造后的的对象的指针
delete：对指针指向的对象运行适当的析构函数；然后通过调用名为operator delete的标准库函数释放该对象所用内存
## 多态/虚函数
C++的多态性，就是在基类的函数前加上virtual关键字，在派生类中重写该函数，运行时将会根据所指对象的实际类型来调用相应的函数，如果对象类型是派生类，就调用派生类的函数，如果对象类型是基类，就调用基类的函数。
  - 方法在积累被声明为virtual后，在派生类中将自动成为虚方法
  - 通过**引用/指针指向的对象类型**选择方法，将能够确定使用基类/派生类的方法
  - 如果没有使用虚函数，根据引用类型或指针类型选择方法
  - 虚析构函数：保证正确的析构函数序列调用，（派生类调用析构函数时会调用基类的析构函数）
## C++中的重载、重写（覆盖）和隐藏的区别
1. 重载（overload）
函数名相同，参数类型/数目不同，返回值不能用来区分不同的函数。重载和函数成员是否是虚函数无关。**同一范围**定义中的同名成员函数才存在重载关系。eg.不同参数的构造函数
2. 重写（覆盖）（override）
基类函数必须是虚函数，在派生类中重写覆盖基类函数，要求**同名同参数同返回值**。
3. 隐藏（hide）
派生类中的函数屏蔽了基类中的同名函数，包括以下情况：
两个函数参数相同，但是基类函数不是虚函数。和重写的区别在于基类函数是否是虚函数。
两个函数参数不同，无论基类函数是不是虚函数，都会被隐藏。和重载的区别在于两个函数不在同一个类中。

# 3.14
## hello.c 程序的编译过程
源代码.cpp文件->**预处理**->.ii文件->**编译（优化）**->.s汇编程序文件->**汇编**->.o可重定位目标程序->**链接**->可执行目标程序

- 预处理阶段：读取源程序，处理以#开头的预处理命令和特殊符号。包括宏定义替换、条件编译指令、头文件包含指令、特殊符号。预编译程序所完成的基本上是对源程序的“替代”工作。经过此种替代，生成一个没有宏定义、没有条件编译指令、没有特殊符号的输出文件。.i预处理后的c文件，.ii预处理后的C++文件
- 编译阶段：通过词法分析和语法分析，在确认所有的指令都符合语法规则之后，将其翻译成等价的中间代码表示或汇编代码。.s文件翻译成汇编文件；
- 汇编阶段：把汇编语言代码翻译成可重定位目标文件，文件中所存放的也就是与源程序等效的机器语言代码。
- 链接阶段：将有关的目标文件彼此相连接，即将在一个文件中**引用**的符号同该符号在另外一个文件中的**定义连接起来**，为代码中的函数，全局变量静态变量分配虚拟地址，当操作系统执行这个文件时会按照这个虚拟地址将可执行文件装载进虚拟内存。 => "静态链接和动态链接"


## 静态链接和动态链接 目标文件
### 静态链接
静态链接器以**一组可重定位目标文件**为输入，生成**一个完全链接的可执行目标文件**作为输出。
- 链接器主要完成以下两个任务：
  - **符号解析**：每个符号对应于一个函数、一个全局变量或一个静态变量，符号解析的目的是将每个**符号引用**与一个**符号定义关联**起来。
  - **重定位**：链接器通过把每个**符号定义**与一个**内存位置关联**起来，然后修改所有对这些符号的引用，使得它们指向这个内存位置。
- 缺点：
  - 浪费空间：每个可执行程序中对所有需要的目标文件都要有一份副本，所以如果多个程序对同一个目标文件都有依赖，如多个程序中都调用了printf()函数，则这多个程序中都含有printf.o，所以同一个目标文件都在内存**存在多个副本**
  - 更新困难：每**当库函数的代码修改**了，这个时候就需要**重新进行编译链接**形成可执行程序
- 优点：
  - 在可执行程序中已经具备了所有执行程序所需要的任何东西，在执行的时候**运行速度快**。

### 动态链接
共享库是为了解决静态库的问题而设计的，在 Linux 系统中通常用 .so 后缀来表示，Windows 系统上它们被称为 DLL。
- 具有以下特点：
  - 在给定的文件系统中一个库只有一个文件，所有引用该库的可执行目标文件都共享这个文件，它不会被复制到引用它的可执行文件中；
  - 在内存中，一个共享库的.text 节（已编译程序的机器代码）的一个副本可以被不同的正在运行的进程共享。
- 优点：
  - 节省空间：即使每个程序都依赖同一个库，但是该库不会像静态链接那样在内存中存在多份副本，而是这多个程序在执行时共享同一份副本；
  - 更新方便：更新时只需要替换原来的目标文件，而无需将所有的程序再重新链接一遍。当程序下一次运行时，新版本的目标文件会被自动加载到内存并且链接起来，程序就完成了升级的目标。
- 缺点：
  - 把链接推迟到了程序运行时，所以每次执行程序都需要进行链接，所以性能会有一定损失。

动态链接地址如何重定位：
虽然动态链接把链接过程推迟到了程序运行时，但是在形成可执行文件时（注意形成可执行文件和执行程序是两个概念），还是需要用到动态链接库。比如我们在形成可执行程序时，发现引用了一个外部的函数，此时会检查动态链接库，发现这个函数名是一个动态链接符号，此时可执行程序就不对这个符号进行重定位，而把这个过程留到装载时再进行。

### 目标文件
可执行目标文件：可以直接在内存中执行；
可重定位目标文件：可与其它可重定位目标文件在链接阶段合并，创建一个可执行目标文件；
共享目标文件：这是一种特殊的可重定位目标文件，可以在运行时被动态加载进内存并链接；


## 内存
### 内存分区
C++程序在编译与运行过程中，可能用到五种存储区域。
- 堆（heap）/动态存储区
  使用new，malloc操作可以**动态分配**这部分内存。优点是动态存储区的**内存分配和回收都由程序员决定**，缺点是如果忘记回收，可能造成**内存泄漏**，并且分配次数过多可能产生**堆碎片**。
- 自由存储区
  就是那些由malloc等分配的内存块，它和堆十分相似，不过它是用free来结束自己的生命的
- 栈（stack）
  存放**局部变量**和**函数参数**，函数执行结束时存储单元**自动释放**，**内存分配运算置于处理器的指令集中**，**效率很高**，但是分配的**内存容量有限**。
- 全局/静态存储区
  **全局变量**和**静态变量**被分配到同一块内存中，程序结束时由**系统释放**。在以前的C语言中，全局变量和静态变量又分为初始化的和未初始化的，在C++里面没有这个区分了，它们共同占用同一块内存区，在该区定义的变量若没有初始化，则会被**自动初始化**，例如int型变量自动初始为0（静态变量的作用域并不是全局的）
- 常量存储区
  这是一块比较特殊的存储区，这里面存放的是**常量**，**不允许修改**，程序结束时由系统释放
- 代码区
  存放**函数体**的**二进制代码 **
```C++
int a = 0; 全局初始化区 
char *p1; 全局未初始化区 
main() { 
  int b;// 栈 
  char s[] = "abc"; //栈 
  char *p2; //栈 
  char *p3 = "123456"; //"123456\0";在常量区，p3在栈上。 
  static int c =0； //全局（静态）初始化区 
  p1 = (char *)malloc(10); 
  p2 = (char *)malloc(20); 
  //分配得来得10和20字节的区域就在堆区。 
  strcpy(p1, "123456"); //123456\0放在常量区，编译器可能会将它与p3所指向的"123456"优化成一个地方。
} 
```

# 3.17 
## 32位机器字符长度
char 1字节
short 2字节
int 4字节
long 4字节
float 4字节
double 8字节

## struct字节对齐
1. 成员都相同时（或含数组且数组数据类型同结构体其他成员数据类型）： 
  结构体长度=成员数据类型长度×成员个数（各成员长度之和）; 
  结构体中数组长度=数组数据类型长度×数组元素个数；
2. 成员不同且不含其它结构体时; 
  (1).分析各个成员长度； 
  (2).找出最大长度的成员长度M（结构体的长度一定是该成员的整数倍）； 
  (3).并按最大成员长度出现的位置将结构体分为若干部分； 
  (4).各个部分长度一次相加，求出大于该和的最小M的整数倍即为该部分长度 
  (5).将各个部分长度相加之和即为结构体长度
3. 含有其他结构体时： 
  (1).分析各个成员长度； 
  (2).对是结构体的成员，其长度按b来分析，且不会随着位置的变化而变化； 
  (3).分析各个成员的长度（成员为结构体的分析其成员长度），求出最大值； 
  (4).若长度最大成员在为结构体的成员中，则按结构体成员为分界点分界； 
  其他成员中有最大长度的成员，则该成员为分界点； 
  求出各段长度，求出大于该和的最小M的整数倍即为该部分长度 
  (5).将各个部分长度相加之和即为结构体长度

### 空结构体
struct S5 { };  
sizeof( S5 ); // 结果为1
“空结构体”（不含数据成员）的大小不为0，而是1。试想一个“不占空间”的变量如何被取地址、两个不同的“空结构体”变量又如何得以区分呢于是，“空结构体”变量也得被存储，这样编译器也就只能为其分配一个字节的空间用于占位了。

### 有static的结构体
struct S4{ 
  char a; 
  long b; 
  static long c; //静态 
}; 
静态变量存放在全局数据区内，而sizeof计算栈中分配的空间的大小，故不计算在内，S4的大小为4+4=8。

### 举例说明
1. 举例1
- 很显然默认对齐方式会浪费很多空间，例如如下结构： 
  struct student 
  { 
      char name[5]; 
      int num; 
      short score; 
  }
  sizeof(student)=16。其数据对齐如下图：
  |char|char|char|char| 
  |char|----|----|----| 
  |--------int--------| 
  |--short--|----|----| 

- 如果我们将结构体中变量的顺序改变为： 
  struct student 
  { 
      int num; 
      char name[5]; 
      short score; 
  }
  则sizeof(student)=12。其数据对齐如下图：
  |--------int--------| 
  |char|char|char|char| 
  |char|----|--short--| 

- 如果我们将结构体中变量的顺序再次改为为： 
  struct student 
  { 
      int num; 
      short score; 
      char name[5]; 
  }
  则，sizeof(student)=12。其数据对齐如下图：
  |--------int--------| 
  |--short--|char|char| 
  |char|char|char|----|

2. 举例2
  ```C++
  struct test1 
  {
    int a; 
    int b[4]; 
  };
  ```
  sizeof(test1)=sizeof(int)+4*sizeof(int)=4+4*4=20;

3. 举例3
  ```C++
  struct test2 
  {
    char a; 
  　int b; 
  　double c; 
  　bool d; 
  };//sizeof(test2)=24;

  struct test3 
  { 
  char a; 
  test2 bb;//见上题 
  int cc; 
  }
  ```
  分析：该结构体有三个成员，其中第二个bb是类型为test2的结构体，长度为24，且该结构体最大长度成员类型为double型，以后成员中没有double型，所以按bb分界为两部分： 
  第一部分有a 、bb两部分，a长度为1，bb长度为24，取8的大于25的最小倍数32； 
  第二部分有cc，长度为4，去8的大于4的最小倍数为8； 
  两部分之和为40，故sizeof(test3)=40;

4. 举例4
  ```C++
  struct test4 
  { 
    char a; 
    int b; 
  }; 

  struct test5 
  {
    char c; 
    test4 d; 
    double e; 
    bool f; 
  };
  ```
  分析：test5明显含有结构体test4，按例2容易知道sizeof(test4)=8，且其成员最大长度为4;则结构体test5的最大成员长度为8(double 型)，考试.大提示e是分界点，分test5为两部分： 
  第一部分由c 、d、e组成，长度为1、8、8，故和为17，取8的大于17的最小倍数为24； 
  第二部分由f组成，长度为1，取8的大于1的最小倍数为8， 
  两部分和为32，故sizeof(test5)=24+8=32;

## union
其实union(共用体)的各个成员是以同一个地址开始存放的,每一个时刻只可以存储一个成员,这样就要求它在分配内存单元时候要满足两点:   
1. 一般而言,共用体类型**实际占用存储空间**为其**最长的成员所占的存储空间**；   
2. 若是该最长的存储空间对其他成员的元类型(如果是数组,取其类型的数据长度,例int a[5]为4)不满足**整除关系**,该最大空间自动延伸;   

```C++
union   mm{    
  char   a;//元长度1    
  int   b[5];//元长度4    
  double   c;//元长度8    
  int   d[3];    
};   
```
本来mm的空间应该是sizeof(int)*5=20;但是如果只是20个单元的话,那可以存几个double型(8位)呢?两个半?当然不可以,所以mm的空间延伸为既要大于20,又要满足其他成员所需空间的整数倍,即24；所以union的存储空间先看它的成员中哪个占的空间最大,拿他与其他成员的元长度比较,如果可以整除就行。














# 3.22
## static
### 不考虑类的情况
* **隐藏**：所有不加static的全局变量和函数具有全局可见性，可以在其他文件中使用，加了之后**只能在该文件所在的编译模块中使用**
* **默认初始化为0**：包括未初始化的全局静态变量与局部静态变量，都存在全局未初始化区
* 静态变量在函数内定义，**始终存在**，且**只进行一次初始化**，**具有记忆性**，其作用范围与局部变量相同，函数退出后仍然存在，但不能使用
### 考虑类的情况
* static成员变量：只与类关联，不与类的对象关联。定义时要分配空间，不能在类声明中初始化，**必须在类定义体外部初始化**，初始化时不需要标示为static；可以被非static成员函数任意访问。
* static成员函数：**不具有this指针**，无法访问类对象的非static成员变量和非static成员函数；不能被声明为const、虚函数和volatile；可以被非static成员函数任意访问

## rand
```C++
#define MAX 100 
int N = rand() % MAX; // [0,MAX)的随机数
int N = 1 + rand() % MAX; // [1,MAX+1)
```

# 3.23
## 智能指针
### 原理
智能指针是一个类，用来**存储指向动态分配对象的指针**，负责**自动释放动态分配的对象**，防止堆内存泄漏。
动态分配的资源，交给一个类对象去管理，当类对象声明周期结束时，自动调用析构函数释放资源
### 常用的智能指针
#### shared_ptr
原理：采用**引用计数器**的方法，允许**多个**智能指针**指向同一个对象**。当多一个指针指向该对象时，指向该对象的所有智能指针内部的引用计数加1，每当减少一个智能指针指向对象时，引用计数会减1，当计数为0的时候会自动的释放动态分配的资源。
* 智能指针将一个计数器与类指向的对象相关联，**引用计数器跟踪共有多少个类对象共享同一指针**
* 每次创建类的**新对象**时，初始化指针并将引用计数置为1
* 当对象作为另一对象的**副本**而创建时，**拷贝构造函数拷贝指针**并增加与之相应的引用计数
* **对一个对象进行赋值**时，赋值操作符减少左操作数所指对象的引用计数（如果引用计数为减至0，则删除对象），并增加右操作数所指对象的引用计数
* **调用析构函数**时，构造函数减少引用计数（如果引用计数减至0，则删除基础对象）

#### unique_ptr
unique_ptr采用的是**独享所有权**语义，一个非空的unique_ptr总是拥有它所指向的资源。
* 转移一个unique_ptr将会把**所有权**全部从源指针**转移**给目标指针，源指针被置空
  * unique_ptr**不支持普通的拷贝和赋值**操作，不能用在STL标准容器中；如果你拷贝一个unique_ptr，那么拷贝结束后，这两个unique_ptr都会指向相同的资源，造成在结束时对同一内存指针多次释放而导致程序崩溃。
  * **局部变量的返回值除外**（因为编译器知道要返回的对象将要被销毁）

#### weak_ptr ~~【大概理解引用成环 但是还不是特别理解】~~
weak_ptr是一个弱引用，它是为了**配合**shared_ptr而引入的一种智能指针。引用计数有一个问题就是**互相引用形成环**（环形引用），这样两个指针指向的内存都无法释放。需要使用weak_ptr打破环形引用
* 指向一个由shared_ptr管理的对象而不影响所指对象的生命周期，也就是说，它**只引用，不计数**
  * 如果一块内存被shared_ptr和weak_ptr同时引用，当所有shared_ptr析构了之后，不管还有没有weak_ptr引用该内存，内存也会被释放。
  * 所以weak_ptr**不保证**它指向的内存一定是**有效**的，在使用之前使用函数lock()检查weak_ptr是否为空指针。

#### ~~auto_ptr~~
主要是为了解决“有异常抛出时发生内存泄漏”的问题 。因为发生异常而无法正常释放内存。

auto_ptr有拷贝语义，拷贝后源对象变得无效，这可能引发很严重的问题；而unique_ptr则无拷贝语义，但提供了移动语义，这样的错误不再可能发生，因为很明显必须使用std::move()进行转移。

auto_ptr不支持拷贝和赋值操作，不能用在STL标准容器中。STL容器中的元素经常要支持拷贝、赋值操作，在这过程中auto_ptr会传递所有权，所以不能在STL中使用。


- 内存->内存溢出与内存泄露->内存泄漏避免方法->智能指针
shared_ptr和new结合使用
如果我们不初始化一个智能指针，它就会被初始化成一个空指针，接受指针参数的职能指针是explicit的，因此我们不能将一个内置指针隐式转换为一个智能指针，必须直接初始化形式来初始化一个智能指针

shared_ptr<int> p1 = new int(1024);//错误：必须使用直接初始化形式
shared_ptr<int> p2(new int(1024));//正确：使用了直接初始化形式


# todo
结构体和类有什么区别
define，const，static,extern定义的变量，有什么区别
流 输出格式
