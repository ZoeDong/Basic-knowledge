# Drop/Delete/Truncate的区别？
从执行速度上来说：drop > truncate >> DELETE
可以这么理解：一本书，delete是把目录撕了，truncate是把书的内容撕下来烧了，drop是把书烧了
#### Delete
- 用来**删除**表的全部或者部分**数据**，**不删除表的结构**
  - 在**InnoDB**中，DELETE其实并不会真的把数据删除，mysql 实际上只是给删除的数据打了个**标记为已删除**，因此 delete 删除表中的数据时，表文件在磁盘上所占空间不会变小，**存储空间不会被释放**，只是把删除的数据行设置为不可见。虽然未释放磁盘空间，但是下次插入数据的时候，仍然**可以重用这部分空间**（重用 → 覆盖）。
- 会走**事务**，执行delete之后，用户需要提交之后才会执行
- 会触发表上的DELETE**触发器**
- DELETE之后**表结构**还在，删除很慢，**一行一行地删**，因为会**记录日志**，可以用于**还原数据**
- 将该行的的删除操作日志记录在redo和undo表空间中以便进行回滚（rollback）和重做操作，生成的大量**日志也会占用磁盘空间**
#### Truncate
- 删除表中的**所有数据**
- 不走事务，**不能回滚**，执行后**立即生效，释放磁盘空间，无法找回**
- **不会触发**这个表上的**触发器**
- 类似于drop table然后creat,只不过这个create table的过程做了优化，比如表结构文件之前已经有了等等。所以速度上应该是接近drop table的速度，比DELETE快很多
- 如果表中有自增（AUTO_INCREMENT）列，则重置为1；
#### Drop
- 删除表，所有的**数据行，索引(index)和约束(constrain)和触发器(trigger)**
- 依赖于该表的**存储过程/函数将保留**,但是变为 **invalid 状态**。
- 不走事务，**不能回滚**，执行后**立即生效，释放磁盘空间，无法找回**
- **不会触发**这个表上的**触发器**


# 使用
打开cmd
mysql -u 用户名 -p
root用户名密码为root
show databases; 查看数据库
use dababase_name; 选择数据库
show tables; 查看当前数据库的所有表

create table table_name(column_name char(20),balabala); 创建表
insert into table_name values(balabala); 插入值
update table_name set 属性=值 where 条件; 修改数据
delete from table_name where 条件; 删除数据
selete 属性 from table_name where 条件; 查询数据

quit 退出mysql

# 约束
表中数据的限制条件，为了保证表中的记录完整和有效
#### 主键约束 Primary Key
表设计时一定要有主键，无论是单一主键还是复合主键，一张表主键约束只能有一个(约束只能有一个，但可以作用到好几个字段)
##### 单一主键
给一个字段添加主键约束
```
mysql> create table t_user(
    -> id int(10) primary key,
    -> );
```
##### 复合主键
给多个字段联合添加一个主键约束(只能用表级定义)
```
mysql> create table t_user(
    -> id int(10),
    -> name varchar(32) not null,
    -> primary key(id,name)
    -> );
```
##### 自增
在MySQL数据库提供了一个自增的数字，专门用来自动生成主键值，主键值不用用户维护，自动生成，自增数从1开始，以1递增(auto_increment)
```
mysql> create table t_user(
    -> id int(10) primary key auto_increment,
    -> name varchar(32) not null
    -> );
```
id从1开始自增
```
mysql> insert into t_user(name) values('jay');
Query OK, 1 row affected (0.04 sec)

mysql> insert into t_user(name) values('man');
Query OK, 1 row affected (0.00 sec)

mysql> select * from t_user;
+----+------+
| id | name |
+----+------+
|  1 | jay  |
|  2 | man  |
+----+------+
2 rows in set (0.00 sec)
```
#### 唯一约束 Unique
具有唯一性，不可重复，但可以为null
```
mysql> create table t_user(
    -> email varchar(128) unique
    -> );
```
多个字段联合约束
```
mysql> create table t_user(
    -> name varchar(32) not null,
    -> email varchar(128),
    -> unique(name,email)
    -> );
```
约束起名字(方便以后通过这个名字来删除这个约束)(constraint是约束关键字，t_user_email_unique自己取的名字)
```
mysql> create table t_user(
    -> email varchar(128),
    -> constraint t_user_email_unique unique(email)
    -> );
```
#### 外键约束 Foreign Key
外键约束主要用来维护两个表之间数据的一致性。一张表可以有多个外键字段（与主键不同）
单一外键：给一个字段添加外键约束
复合外键：给多个字段联合添加一个外键约束
```
mysql> drop table if exists t_student;
mysql> drop table if exists t_class;

mysql> create table t_class(
    -> cno int(10) primary key,
    -> cname varchar(128) not null unique
    -> );

mysql> create table t_student(
    -> sno int(10) primary key auto_increment,
    -> sname varchar(32) not null,
    -> classno int(3),
    -> foreign key(classno) references t_class(cno)
    -> );
```
#### 非空约束 Not Null
用not null约束的字段不能为null值，必须给定具体的数据
```
mysql> create table t_user(
    -> id int(10),
    -> name varchar(32) not null
    -> );
```
#### 检查约束(目前MySQL不支持、Oracle支持)

# 并发一致性问题/并发控制
#### 丢失修改
一个事务对数据进行了修改，在事务提交之前，另一个事务对同一个数据进行了修改，覆盖了之前的修改；
#### 脏读（Dirty Read）
一个事务读取了被另一个事务修改、但**未提交**（进行了回滚）的数据，造成两个事务得到的数据不一致；
#### 不可重复读（Nonrepeatable Read）
在同一个事务中，某查询操作在一个时间读取某一行数据和之后一个时间读取该行数据，发现数据已经发生修改（针对**update操作**）；
#### 幻读（Phantom Read）
当同一查询多次执行时，由于其它事务在这个数据范围内执行了插入操作，会导致每次返回不同的**结果集**（和不可重复读的区别：针对的是一个**数据整体/范围**；并且针对**insert/delete操作**）


# 乐观锁和悲观锁
#### 悲观锁
适用于写多读少的情况(**多写**场景)
认为数据随时会被修改，因此每次读取数据之前都会上锁，防止其它事务读取或修改数据；应用于数据更新比较频繁的场景；
悲观锁主要分为共享锁和排他锁
#### 乐观锁
适用于读多写少的情况(**多读**场景)
操作数据时不会上锁，但是更新时会判断在此期间有没有别的事务更新这个数据，若被更新过，则**失败重试**；适用于读多写少的场景。
乐观锁的实现方式有：
- 加一个**版本号**或者**时间戳**字段，每次数据更新时同时更新这个字段；
- 先读取想要更新的**字段**或者所有字段，更新的时候比较一下，只有字段没有变化才进行更新

#### 区别
* **响应效率**：如果需要**非常高的响应速度**，建议采用乐观锁方案，成功就执行，不成功就失败，**不需要等待其他并发去释放锁**。乐观锁并未真正加锁，效率高。一旦锁的粒度掌握不好，更新失败的概率就会比较高，容易发生业务失败。
* **冲突频率**：如果**冲突频率非常高**，建议采用悲观锁，**保证成功率**。冲突频率大，选择乐观锁会需要多次重试才能成功，代价比较大。
* **重试代价**：如果重试代价大，建议采用悲观锁。悲观锁依赖数据库锁，效率低。**更新失败的概率比较低**。
* **拒绝更新重新操作/等待**：乐观锁如果有人在你之前更新了，你的更新应当是被拒绝的，可以让用户从新操作。悲观锁则会等待前一个更新完成。这也是区别。

# 常见的封锁类型
锁的作用：用于管理对共享资源的并发访问，保证数据库的完整性和一致性

意向锁是 InnoDB 自动加的，不需用户干预。
对于 UPDATE、 DELETE 和 INSERT 语句， InnoDB 会自动给涉及数据集加排他锁（X)；
对于普通 SELECT 语句，InnoDB 不会加任何锁；

#### 共享锁 shared locks/读锁/S锁：
SELECT * FROM table_name WHERE ... LOCK IN SHARE MODE。
- 其他事务也可以，并且**只可以**对同一数据加 share mode 的共享锁，都能访问到数据，**只能读不能修改**
- 如果当前事务需要对该记录进行更新操作，则很有可能造成死锁。

#### 排他锁 exclusive locks/写锁/X锁
SELECT * FROM table_name WHERE ... FOR UPDATE。
- **只允许**获取排他锁的事务对数据行读取和修改。
- 不能与其他锁并存，如果一个事务获取了一个数据行的排他锁，其它事务不能对该数据加任何锁，而是等待获得锁

#### 意向锁（Intention Locks）
如果一个事务想要对整个表加X锁，就需要先检测是否有其它事务对该表或者该表中的某一行加了锁，这种检测非常耗时。有了意向锁之后，只需要检测整个表是否存在IX/IS/X/S锁就行了
一个事务在获得某个数据行对象的 S 锁之前，必须先获得**整个表**的 IS 锁或更强的锁；
一个事务在获得某个数据行对象的 X 锁之前，必须先获得**整个表**的 IX 锁；
**IS/IX 锁之间都是兼容的**
* 应用
    ```
    mysql> select * FROM t_compact WHERE c1 = 'a' FOR UPDATE;
    ```
    会话A：给t_compact表上c1 = 'a'行加上排他锁，自动加上意向排他锁IX
    会话B：在另一行上加行级排他锁。由于会话A的缘故，表上已经存在意向排他锁，会话B也需要在表上加意向排他锁，由于意向锁的兼容性，意向排他锁也是可以加的上去的。再去检查c1 = 'b'行上有没有行级排他锁，经检查没有行级排他锁，那么c1 = 'b'上加行级排他锁，不会阻塞。



# 封锁粒度的概念
MySQL 中提供了两种封锁粒度：行级锁(S锁/X锁)以及表级锁(IS锁/IX锁)。
MySQL InnoDB 默认行级锁。**行级锁**都是**基于索引**的，如果一条 SQL 语句用不到索引是不会使用行级锁的，会使用表级锁把整张表锁住，这点需要注意。

封锁粒度小：
- 好处：锁定的数据量越少，发生锁**争用的可能就越小**，系统的**并发程度就越高**；
- 坏处：系统**开销大**（加锁、释放锁、检查锁的状态都需要消耗资源）

扩展：https://www.hollischuang.com/archives/914

# 什么是三级封锁协议？
* 一级封锁协议：
  * 事务在修改数据之前必须先对其加X锁，直到事务结束才释放。
  * 可以解决**丢失修改问题**（两个事务不能同时对一个数据加X锁，避免了修改被覆盖）；
* 二级封锁协议：
  * 在一级的基础上，事务在读取数据之前必须先加**S锁**，**读完后释放**。
  * 可以解决**脏读问题**（如果已经有事务在修改数据，就意味着已经加了X锁，此时想要读取数据的事务并不能加S锁，也就无法进行读取，避免了读取脏数据）；
* 三级封锁协议：
  * 在一级的基础上，事务在读取数据之前必须先加**S锁**，直到**事务结束才能释放**。
  * 可以解决**不可重复读问题**（避免了在事务结束前其它事务对数据加X锁进行修改，保证了事务期间数据不会被其它事务更新）




# todo 
- 什么是两段锁协议？
- 什么是存储过程？有哪些优缺点？
- 游标（Cursor）：用于定位在查询返回的结果集的特定行，以对特定行进行操作。使用游标可以方便地对结果集进行移动遍历，根据需要滚动或对浏览/修改任意行中的数据。主要用于交互式应用。
