# 计算机网络
## http/https
### http状态码
#### 常见的HTTP状态码
100 - 继续。客户端应继续其请求
200 - 请求成功
301 - 资源（网页等）**永久**转移到其它URL
302 - 资源（网页等）**临时**转移到其它URL
404 - 请求的资源（网页等）不存在
500 - 内部服务器错误

#### HTTP状态码分类
1**	信息，服务器收到请求，需要请求者继续执行操作
2**	**成功**，操作被成功接收并处理
3**	**重定向**，需要进一步的操作以完成请求
4**	客户端错误，请求包含语法错误或**无法完成请求**
5**	服务器错误，服务器在**处理请求的过程中发生了错误**

### GET/POST
GET - 从指定的资源请求数据。
POST - 向指定的资源提交要被处理的数据

#### GET 方法
查询字符串（名称/值对）是在**GET请求的URL**中发送的：
/test/demo_form.asp?name1=value1&name2=value2

#### POST 方法
查询字符串（名称/值对）是在 POST 请求的**HTTP消息主体**中发送的：
POST /test/demo_form.asp HTTP/1.1
Host: w3schools.com
name1=value1&name2=value2

#### 区别
GET在浏览器**回退**时是无害的，而POST会**再次提交请求**。
GET产生的URL地址可被收藏为**书签**，而POST不可以。
GET请求参数会被完整保留在浏览器**历史记录**里，而POST中的参数不会被保留。
GET请求在URL中传送的**参数**是有**长度**限制的(浏览器和服务器的限制)，而POST没有限制。
GET请求会被浏览器**主动缓存**(cache)，而POST不会，除非手动设置。
GET比POST更不**安全**，因为参数直接暴露在URL上，所以不能用来传递敏感信息。
GET参数通过**URL**传递，POST放在**HTTP消息主体**(Request body)中。
对数据类型的限制，GET请求只允许**ASCII字符**。POST**没有限制**，也允许二进制数据。
GET 请求只应当用于取回数据
~~GET请求只能进行url编码，而POST支持多种编码方式。（不懂）~~



### 访问http网址的过程
url->DNS解析->IP地址->建立TCP连接->客户端（浏览器）发送HTTP/HTTPS请求->服务端应答请求->释放TCP连接->解析HTML
- DNS解析（UDP数据包）
查找浏览器DNS缓存->查找操作系统缓存Hosts文件->发送给本地域名解析服务器LDNS（递归查询）->如果本地域名服务器LDNS也查询不到哦->LDNS发送给根服务器Root DNS->根服务器进行迭代查询，查找顶级域名服务器，返回给LDNS->LDNS再发送给顶级域名服务器进行查找，直到找到url网址对应的ip地址->返回给LDNS并进行缓存->LDNS把解析的结果返回给用户
- TCP三次握手与四次挥手
  Q&A
  1. Q：为什么不能用两次握手进行连接？
    A：3次握手完成两个重要的功能，既要双方做好发送数据的准备工作(双方都知道彼此已准备好)，也要允许双方就初始序列号进行协商，这个序列号在握手过程中被发送和确认。——> 现在把三次握手改成仅需要两次握手，可能发生死锁。考虑计算机S和C之间的通信，假定C给S发送一个连接请求分组，S收到了这个分组，并发送了确认应答分组。按照两次握手的协定，S认为连接已经成功地建立了，可以开始发送数据分组。可是，C在S的**应答分组在传输中被丢失**的情况下，将不知道S是否已准备好，不知道S建立什么样的序列号，C甚至怀疑S是否收到自己的连接请求分组。在这种情况下，**C认为连接还未建立成功，将忽略S发来的任何数据分组**，只等待连接确认应答分组。而**S在发出的分组超时后，重复发送同样的分组**。这样就形成了死锁。
  2. Q：客户端两次挥手之后表明没有更多消息需要发送给服务端，为什么还能回复服务端ack消息
    A：两次挥手之后处于半断开状态，可以接受、应答数据，但不能发送数据
- HTML
- 拥塞控制

### 访问https网址的过程
SSL/TLS是加密传输的协议
1. 客户端发起https连接
  - 当客户端访问某个url网址时，首先到DNS服务器请求对应ip地址，然后**客户端连接上服务端的443端口**，将此请求发送给到服务端，此时客户端同时将自己支持的**加密协议及版本、SSL、TLS**【这两个到底是啥？协议？规则？】发送给服务端
2. 服务端发送证书
  - 服务端收到这套加密算法时，和自己支持的加密算法进行对比（也就是和自己的私钥进行对比），如果不符合，就断开连接；如果符合，服务端就将SSL证书发送给客户端。[该数字证书包含服务端身份信息：1、证书颁发机构；2、使用机构；3、**公钥**【加密协议？】；4、有效期；5、签名算法/HASH算法；6、指纹算法；7、指纹]
3. 客户端验证服务端发来的证书
  - 验证证书：客户端【使用根证书】验证收到的证书，包括发布机构是否合法、过期，证书中包含的网址是否与当前访问网址一致等等。
  - 生成随机数/对称加密的私钥：客户端验证证书无误/接受了不信任的证书后，会生成一个**随机数**，用服务端发过来的公钥进行加密。
  - 生成握手信息：使用**证书中的签名hash算法**取握手信息的hash值，然后用生成的随机数将**握手信息和握手信息的hash值**进行加密，然后用公钥将随机数进行加密后，一起发送给服务端。[其中计算握手信息的hash值，目的是为了保证传回到服务端的握手信息没有被篡改]
4. 服务端验证客户端
   - 服务端收到客户端传回来的用随机数加密的信息后，先用私钥**解密随机数，验证握手信息是否被篡改**，然后用解密得到的**随机数解密握手信息**，获取握手信息和握手信息的hash值，将自己之前选出发送给客户端的握手信息的hash值，与客户端传回来的进行对比验证。
   - 如果验证无误，同样使用随机字符串加密握手信息和握手信息hash值发回给到客户端
5. 客户端验证服务端
   - 客户端收到服务端发送过来的握手信息后，用开始自己生成的随机数进行解密，验证被随机数加密的握手信息和握手信息hash值。
   - 验证无误后，握手过程就完成了，从此服务端和客户端就开始用那串随机数进行对称加密通信了（常用的对称加密算法有AES）。

————————————————————————————————————————————

- SSL(Secure Socket Layer 安全套接层协议)、TLS(Transport Layer Security 安全传输层协议)，都属于是加密协议
- SSL证书：实现数据HTTPS加密协议访问，保障数据的安全**使用HTTPS是需要保证服务端配置正确了对应的安全证书**
- SSL/TLS协议的作用：提供信息的机密性，保障信息的完整性。

## TCP/UDP
### TCP
#### 面向连接协议，提供可靠的端到端传输，只能一对一
#### 可靠->重传机制、流量控制、拥塞控制
  重传机制：重传计时器，超过一定时长就重传，未超过被确认就停止
  流量控制：滑动窗口大小、nagle算法和clark方案（发方缓存一定量数据一起发送，收方进制发送只有一个字节的窗口更新段，强制等待一段时间后再更新）
  拥塞控制：拥塞窗口（网络情况）、接受窗口（接收端可缓冲字节数，固定，易得到）；
    慢启动：（指数增长）-> 慢启动阈值-> 线性增长
    快重传：更早地重传丢失的报文段==> 每收到一个失序报文->立刻发送重复确认，连续收到三个重复确认->重传对方尚未收到的报文段，重传后阈值设置为当前窗口的一半，重新开始慢启动
    快恢复：连续收到三个重复确认->阈值减半 但不执行慢启动，重传后阈值设置为当前窗口的一半，从新阈值开始线性增长
#### TCP 协议如何保证可靠传输
1. 确认和重传：接收方收到报文就会确认，发送方发送一段时间后没有收到确认就重传。
2. 数据校验
3. 数据合理分片和排序：
  UDP：IP数据报大于1500字节,大于MTU.这个时候发送方IP层就需要分片,使每一片都小于MTU.而接收方IP层则需要进行数据报的重组,由于UDP的特性,当某一片数据传送中丢失时,接收方便无法重组数据报.将导致丢弃整个UDP数据报.
  TCP会按MTU合理分片，**接收方会缓存未按序到达的数据，重新排序后再交给应用层。**
4. 流量控制：当接收方来不及处理发送方的数据，能提示发送方降低发送的速率，防止包丢失。
5. 拥塞控制：当网络拥塞时，减少数据的发送。

#### 三次握手与四次挥手
https://www.cnblogs.com/bj-mr-li/p/11106390.html

2MLS作用2：
假如A发送的第一个请求连接报文段丢失而未收到确认，A就会重传一次连接请求，后来B收到了确认，建立了连接。数据传输完毕后，就释放了连接。A共发送了两个连接请求报文段，其中第一个丢失，第二个到达了B。假如现在A发送的第一个连接请求报文段没有丢失，而是在某些网络节点长时间都留了，以至于延误到连接释放后的某个时间才到达B，这本来是已失效的报文段，但B并不知道，就会又建立一次连接。而等待的这2MSL就是为了解决这个问题的，A在发送完最后一个确认报后，在经过时间2MSL，就可以使本链接持续时间内所产生的所有报文段都从网络中消失，这样就可以**使下一个新的连接中不会出现这种旧的连接请求报文段**

### UDP：无连接协议，提供不可靠的端到端传输，支持一对多传送，适合视频通话

应用：DNS域名系统

### TCP与UDP区别
#### UDP主要特点：
1. UDP是**无连接**的，即发送数据之前不需要建立连接，发送数据结束时也没有连接可以释放，因此**减少了开销和发送数据之前的时延**。
2. UDP使用尽最大努力交付，即**不保证可靠交付**，因此主机不需要维持复杂的连接状态表（这里面有很多参数）。
3. UDP是**面向报文的**。发送方的UDP对应用程序交下来的报文，在添加首部后就向下交付IP层。UDP对应用层交下来的报文，既不合并，也不拆分，而是保留这些报文的边界。这就是说，**应用层交给UDP多长的报文，UDP就照样发送**，即一次发送一个报文。
4. UDP支持一对一、**一对多、多对一和多对多的交互通信。**
5. UDP**没有拥塞控制**，因此网络出现的拥塞不会使源主机的发送速率降低。但是不使用拥塞控制功能的UDP有可能会引起网络产生严重的拥塞问题。
6. UDP的**首部开销小，只有8个字节**，比**TCP的20个字节**的首部还要短。

#### TCP主要特点：
1. TCP是**面向连接**的传输层协议。应用程序在使用TCP协议之前，必须先建立TCP连接，在传送数据完毕后，必须释放已经建立的TCP连接，在传送数据完毕后，必须释放已经连接的TCP连接。
2. TCP提供**可靠交付**的服务。通过TCP连接传送的数据，**无差错、不丢失、不重复、并且按序到达**。
3. **面向字节流**。TCP中的“流”指的是流入到进程或从进程流出的字节序列。面向字节流的含义是：虽然应用程序和TCP的交互是一次一个数据块（大小不等），但是TCP把应用程序交下来的数据仅仅看成是一连串的无结构的字节流。
4. 每一条**TCP连接只能有两个端点**，即**点对点**的。
5. TCP提供**全双工通信**。TCP允许通信双方的应用进程在任何时候都能发送数据。



### 数据包长度
IP长度字段占2个字节 即2^16=65535字节 
IP头占20个字节 数据段最长65535-20=55515字节
TCP头占20个字节 数据段最长65535-20-20=65495字节
UDP头占8个字节 数据段最长65535-20-8=65507字节

IP最大可传65535而以太网最大只能传1500字节 => 以太网MTU=1500字节

为什么不把以太网设置成大一点的数值：考虑TCP协议的三次握手和四次挥手，大的数据包不仅**单个传输很慢**，而且一旦需要**重传**，就要花**费更多的时间**，所以拆成小包进行传输不仅单个传输速度快，并且如果需要重传的话，只需要传丢失的那个小包即可。

#### MTU： Maximum Transmit Unit，最大传输单元
即**物理接口（数据链路层）**提供给其上层（通常是IP层）最大一次传输数据的大小，大于MTU的数据包需要分片；
以普遍使用的**以太网接口**为例，**缺省MTU=1500 Byte**，这是以太网接口对IP层的约束，如果IP层有<=1500 byte 需要发送，只需要一个IP包就可以完成发送任务；如果IP层有> 1500 byte 数据需要发送，需要分片才能完成发送，这些分片有一个共同点，即IP Header ID相同。

#### MSS：Maximum Segment Size ，**TCP提交给IP层最大分段大小**
不包含TCP Header和 TCP Option，**只包含TCP Payload** ，MSS是TCP用来限制application层最大的发送字节数。
如果底层物理接口MTU= 1500 byte，则 MSS = 1500- 20(IP Header) -20 (TCP Header) = 1460 byte，如果application 有2000 byte发送，需要两个segment才可以完成发送，第一个TCP segment = 1460，第二个TCP segment = 540。
MSS针对的是OSI模型里第四层传输层的TCP协议。因为MSS应用的协议在数据链接层的上层，MSS会受到MTU的限制。


## 端口号
端口号的范围是从1～65535
[1,1023]是被RFC3232规定好了的，被称作“众所周知的端口”(Well Known Ports)
[1024,49151]是被注册的端口号，被IANA指定为特殊服务使用
[49152,65535]是动态或私有端口号。可用来建立与其它主机的会话，也可由用户自定义用途。

一些常见的端口号及其用途如下： 

TCP **21端口**：FTP 文件传输服务
TCP 23端口：TELNET 终端仿真服务
TCP 25端口：SMTP 简单邮件传输服务
UDP **53端口**：DNS 域名解析服务
TCP **80端口**：HTTP 超文本传输服务
TCP 110端口：POP3 “邮局协议版本3”使用的端口
TCP **443端口**：HTTPS 加密的超文本传输服务




## HTTP1.0 HTTP1.1 HTTP2.0
### HTTP1.0
HTTP 1.0规定浏览器与服务器只保持**短暂的连接**，浏览器的每次请求都需要与服务器建立一个TCP连接，服务器完成请求处理后立即断开TCP连接，服务器**不跟踪每个客户也不记录过去的请求**。
- 问题：
连接无法复用：每次请求都经历三次握手和慢启动->三次握手在高延迟的场景下影响较明显，慢启动则对文件类大请求影响较大。
head of line blocking：导致带宽无法被充分利用，以及后续健康请求被阻塞。

### HTTP 1.1
HTTP 1.1支持**持久连接**（HTTP/1.1的默认模式使用**带流水线的持久连接**），在一个TCP连接上可以传送多个HTTP请求和响应，减少了建立和关闭连接的消耗和延迟。一个包含有许多图像的网页文件的多个请求和应答可以在一个连接中传输，但每个单独的网页文件的请求和应答仍然需要使用各自的连接。
HTTP 1.1还允许客户端**不用等待上一次请求结果返回，就可以发出下一次请求**，但服务器端必须按照接收到**客户端请求的先后顺序**依次回送响应结果，以保证客户端能够区分出每次请求的响应内容，这样也显著地减少了整个下载过程所需要的时间。

在http1.1中，client和server都是**默认对方支持长链接**的， 如果client/server方使用http1.1协议，但又不希望使用长链接，则需要在(response)header中指明connection的值为close；表明当前正在使用的tcp连接在当天（？）请求处理完毕后会被断掉。以后client再进行新的请求时就必须创建新的tcp链接了。

100(Continue) Status(节约带宽)
HTTP/1.1加入了一个新的状态码100（Continue）。**客户端事先发送一个只带头域的请求**，如果服务器因为权限拒绝了请求，就回送响应码401（Unauthorized）；如果服务器接收此请求就回送响应码100，客户端就可以继续发送带实体的完整请求了。100 (Continue) 状态代码的使用，允许客户端在发request消息body之前先用request header**试探server**，看server要不要接收request body，再决定要不要发request body。

#### ~~咩啊~~
2.HTTP 1.1增加host字段
在HTTP1.0中认为每台服务器都绑定一个唯一的IP地址，因此，请求消息中的URL并没有传递主机名（hostname）。但随着虚拟主机技术的发展，在一台物理服务器上可以存在多个虚拟主机（Multi-homed Web Servers），并且它们共享一个IP地址。
HTTP1.1的请求消息和响应消息都应支持Host头域，且请求消息中如果没有Host头域会报告一个错误（400 Bad Request）。此外，服务器应该接受以绝对路径标记的资源请求。

4、HTTP/1.1中引入了Chunked transfer-coding来解决上面这个问题，发送方将消息分割成若干个任意大小的数据块，每个数据块在发送时都会附上块的长度，最后用一个零长度的块作为消息结束的标志。这种方法允许发送方只缓冲消息的一个片段，避免缓冲整个消息带来的过载。

5、HTTP/1.1在1.0的基础上加入了一些cache的新特性，当缓存对象的Age超过Expire时变为stale对象，cache不需要直接抛弃stale对象，而是与源服务器进行重新激活（revalidation）。

HTTP/1.1相较于 HTTP/1.0 协议的区别主要体现在：

1 缓存处理

2 带宽优化及网络连接的使用

3 错误通知的管理

4 消息在网络中的发送

5 互联网地址的维护

6 安全性及完整性

### HTTP2.0
#### 多路复用 (Multiplexing)
多路复用允许同时通过单一的 HTTP/2 连接发起多重的请求-响应消息。在 HTTP/1.1 协议中浏览器客户端在同一时间，针对同一域名下的请求有一定数量限制。超过限制数目的请求会被阻塞。这也是为何一些站点会有多个静态资源 CDN 域名的原因之一，拿 Twitter 为例，http://twimg.com，目的就是变相的解决浏览器针对同一域名的请求限制阻塞问题。而 HTTP/2 的多路复用(Multiplexing) 则**允许同时通过单一的 HTTP/2 连接发起多重的请求-响应消息**。因此 HTTP/2 可以很容易的去**实现多流并行而不用依赖建立多个 TCP 连接**，HTTP/2 把 HTTP 协议**通信的基本单位缩小为一个一个的帧**，这些帧对应着逻辑流中的消息。并行地在同一个 TCP 连接上双向交换消息。

#### 二进制分帧

HTTP/2在 应用层(HTTP/2)和传输层(TCP or UDP)之间增加一个**二进制分帧层**。在不改动 HTTP/1.x 的语义、方法、状态码、URI 以及首部字段的情况下, 解决了HTTP1.1 的性能限制，改进传输性能，实现低延迟和高吞吐量。在二进制分帧层中， **HTTP/2 会将所有传输的信息分割为更小的消息和帧（frame）,并对它们采用二进制格式的编码**，其中 HTTP1.x 的首部信息会被封装到 HEADER frame，而相应的 Request Body 则封装到 DATA frame 里面。

**HTTP/2 通信都在一个连接上完成**，这个连接可以承载任意数量的双向数据流。在过去， HTTP 性能优化的关键并不在于高带宽，而是低延迟。TCP 连接会随着时间进行自我调谐，起初会限制连接的最大速度，如果数据成功传输，会随着时间的推移提高传输的速度。这种调谐则被称为 TCP **慢启动**。由于这种原因，**让原本就具有突发性和短时性的 HTTP 连接变的十分低效**。HTTP/2 通过让**所有数据流共用同一个连接**，可以更有效地使用 TCP 连接，让高带宽也能真正的服务于 HTTP 的性能提升。

这种单连接多资源的方式，减少服务端的链接压力,内存占用更少,连接吞吐量更大；而且由于**TCP连接的减少而使网络拥塞状况得以改善，同时慢启动时间的减少,使拥塞和丢包恢复速度更快。**

#### ~~首部压缩（Header Compression）~~
HTTP/1.1并不支持 HTTP 首部压缩，为此 SPDY 和 HTTP/2 应运而生， SPDY 使用的是通用的DEFLATE 算法，而 HTTP/2 则使用了专门为首部压缩而设计的 HPACK 算法。
服务端推送（Server Push）

#### ~~服务端推送~~
一种在**客户端请求之前发送数据的机制**。在 HTTP/2 中，服务器可以对客户端的一个请求发送多个响应。Server Push 让 HTTP1.x 时代使用内嵌资源的优化手段变得没有意义；如果一个请求是由你的主页发起的，服务器很可能会响应主页内容、logo 以及样式表，因为它知道客户端会用到这些东西。这相当于在一个 HTML 文档内集合了所有的资源，不过与之相比，服务器推送还有一个很大的优势：可以缓存！也让在遵循同源的情况下，不同页面之间可以共享缓存资源成为可能。

### ~~HTTPS~~

## OSI七层模型 TCP/IP四层模型
### OSI
1. 物理层
   利用物理传输介质为数据链路层**提供物理连接**，**提供透明的比特流传输**
2. 数据链路层
   物理层提供比特流传输服务的基础上，在通信实体之间建立数据链路连接，传送**以帧为单位的数据**，通过**差错控制**、**流量控制**方法，变有差错的物理线路为**无差错的数据链路**。 
3. 网络层
   主要任务是通过执行路由选择算法，为**报文分组**通过通信子网**选择最适当的路径**。它是OSI参考模型七层中最复杂的一层。 
4. 传输层
   向用户**提供可靠的端到端服务，透明地传送报文** 。
5. 会话层
   在会话层及以上的高层次中，数据传送的单位不再另外命名，统称为报文。会话层不参与具体的传输，它提供包括**访问验证**和**会话管理**在内的**建立和维护应用之间通信**的机制，即**组织同步的两个会话用户之间的对话**，并管理**数据交换**。。如服务器验证用户登录便是由会话层完成的。 
6. 表示层
   将欲交换的数据从适合于某一用户的抽象语法，转换为适合于OSI系统内部使用的传送语法。即提供格式化的表示和转换数据服务，用于处理两个通信系统间**信息交换的表示方式**。它包括数据格式变换、数据加密与解密、数据压缩与恢复等功能。 
7. 应用层
   确定进程之间通信的性质以满足用户需要以及**提供网络与用户应用软件之间的接口服务**，包括文件的传输，文件的管理以及电子邮件的信息处理

# TODO

### 在浏览器输入网址,到显示网页,发生在网络层（各层）的过程