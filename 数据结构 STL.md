# swap
```C++
int x = 10;
int y = 5;
int tmp = x;
x = y;
y = tmp;
```
```C++
int x = 10; // x 0000 1010
int y = 5;  // y 0000 0101
x = x ^ y;  // x 0000 1111
y = x ^ y;  // y 0000 1010
x = x ^ y;  // x 0000 0101
```
```C++
int x = 10; 
int y = 5;
x = x + y;   // x 15
y = x - y;   // y 10
x = x - y;   // x 5
```

# vector
## 二维vector 两种初始化方式
```C++
vector<vector<char>>vec(row,vector<char>(col,'#'));
```
```C++
vector<vector<char>>vec1;
vec1.resize(row);
for(int i=0;i<vec1.size();i++)
    vec1[i].resize(col);
for(int i=0;i<row;i++)
    for(int j=0;j<col;j++)
        vec1[i][j]='#';
```
## 初始化
### 自定义
vector<int> a(10); //定义了10个整型元素的向量，但没有给出初值，其值是不确定的。
vector<int> a(10,1); //定义了10个整型元素的向量,且给出每个元素的初值为1
### 向量/数组copy
vector<int> a(b); //用b向量来创建a向量，整体复制性赋值
vector<int> a(b.begin(),b.begin+3); //定义了a值为b中第0个到第2个（共3个）元素
int b[7]={1,2,3,4,5,9,8}; vector<int> a(b,b+7); //从数组中获得初值
## 下标
a.front(); //返回a的第一个元素
a.back(); //返回a的最后一个元素
a[i]; //返回a的第i个元素，当且仅当a[i]存在
## 插入/删除
a.clear(); //清空a中的元素

a.push_back(5); //在a的最后一个向量后插入一个元素，其值为5
a.pop_back(); //删除a向量的最后一个元素

a.insert(a.begin()+1,5); //在a的第1个元素（从第0个算起）的位置插入数值5，如a为1,2,3,4，插入元素后为1,5,2,3,4
a.insert(a.begin()+1,3,5); //在a的第1个元素（从第0个算起）的位置插入3个数，其值都为5
a.insert(a.begin()+1,b+3,b+6); //b为数组，在a的第1个元素（从第0个算起）的位置插入b的第3个元素到第5个元素（不包括b+6），如b为1,2,3,**4,5,9**,8，a为1,2,3,4，插入元素后为1,**4,5,9**,2,3,4

vector<int>::iterator iter=a.begin();
a.erase(iter) //erase后该元素被擦除，剩余元素前进，iter指向的是被erase的下一个元素，实际上仍旧是当前位置
## 查找
vector本身是没有find这一方法，其find是依靠algorithm来实现的。
vector<int>::iterator iter=find(vec.begin(),vec.end(),7);//vec={8,7,6} 
int pos=iter-vec.begin();//pos=1 find返回类型为iterator，相减得到下标pos
int a=*iter;//a=7 *iter返回iter指向的值 此时iter指向7的位置，值为7
## 其他
a.empty(); //判断a是否为空，空则返回ture,不空则返回false
a.erase(a.begin()+1,a.begin()+3); //删除a中第1个（从第0个算起）到第2个元素，也就是说删除的元素从[a.begin()+1,a.begin()+3)
a.swap(b); //b为向量，将a中的元素和b中的元素进行整体性交换
a==b; //b为向量，向量的比较操作还有!=,>=,<=,>,<
## 扩容 + 长度/容量
vector底层数据结构是一个**动态数组**、
vector中数据的随机存取效率很高，O(1)的时间的复杂度，但是在vector中随机插入元素，需要移动的元素数量较多，效率比较低。

默认容量是0，之后插入按照1 2 4 8 16 二倍扩容。GCC是二倍扩容，VS13是1.5倍扩容。
扩容后是一片**新的内存**，需要把旧内存空间中的**所有元素**都**拷贝**进新内存空间中去，之后再在新内存空间中的原数据的后面继续进行插入构造新元素，并且同时释放旧内存空间
由于vector 空间的重新配置，导致**旧vector的所有迭代器都失效**了。

vector的初始的扩容方式**代价太大,初始扩容效率低**，需要频繁增长，而且频繁的向操作系统申请内存容易造成过多的**内存碎片**
所以这个时候需要合理使用resize()和reserve()方法提高效率减少内存碎片的

### resize()
```C++
a.size(); //返回a中元素的个数；
a.resize(10); //将a的现有元素个数调至10个，多则删，少则补，值为类型默认初始值
a.resize(10,2); //将a的现有元素个数调至10个，多则删，少则补，其值为2
```
1. resize方法被用来改变vector中元素的数量，我们可以说，resize方法**改变了容器的大小**，且**创建了容器中的对象**；
2. 如果resize中所指定的n小于vector中当前的元素数量，则会删除vector中多于n的元素，使vector得大小变为n；
3. 如果所指定的n大于vector中当前的元素数量，则会在vector当前的尾部插入适量的元素，使得vector的大小变为n，在这里，如果为resize方法指定了第二个参数，则会把后插入的元素值初始化为该指定值，如果没有为resize指定第二个参数，则会把新插入的元素初始化为默认的初始值；
4. 如果resize所指定的n不仅大于vector中当前的元素数量，还大于vector当前的capacity容量值时，则会自动为vector重新分配存储空间；

### reserve():
```C++
a.capacity(); //返回a在内存中总共可以容纳的元素个数
a.reserve(100); //将a的容量（capacity）扩充至100，这种操作只有在需要给a添加大量数据的时候才显得有意义，可以避免内存多次容量扩充操作（当a的容量不足时电脑会自动扩容，当然这必然降低性能） 
```
1. reserve方法被用来**重新分配**vector的**容量大小**；
2. 只有当所申请的容量大于vector的当前容量时才会重新为vector分配存储空间；小于当前容量则没有影响
3. reserve方法**对于vector元素大小没有任何影响，不创建对象**。

### 1.5倍扩容优于2倍扩容的原因
2倍扩容：每次扩容，我们释放掉的内存连接起来的大小，都小于即将要分配的内存大小。
1.5倍扩容：可以服用释放掉的内存

2倍扩容：

    假设我们一开始申请了 16Byte 的空间。
    扩容时，申请 32Byte，释放掉 16Byte。在内存中留下一个16Byte 的闲置空间
    扩容时，申请 64Byte，释放掉 32Byte。在内存中留下一个48Byte 的闲置空间（假定之前的 16Byte 和此时释放的32Byte 合并）
    扩容时，申请 128Byte，释放掉之前的 64Byte。在内存中留下一个112Byte 的闲置空间（假定所有之前释放的空间都合并成了一个块）

1.5倍扩容：

    假设我们一开始申请了 16Byte 的空间。
    扩容时，申请 24 Byte，释放掉 16，在内存中留下 16Byte 的空闲空间。
    扩容时，申请 36 Byte，释放掉 24，在内存中留下 40Byte (16 + 24)的空闲空间。
    扩容时，申请 54 Byte，释放 36，在内存中留下 76Byte。
    扩容时，申请 81 Byte，释放 54， 在内存中留下 130Byte。
    扩容时，申请 122 Byte 的空间（复用内存中闲置的 130Byte）


# 迭代器 iterator
auto iter = myMap.begin();
iter=myMap.find(target-nums[i]);
if(iter!=myMap.end()){}


# queue
push
pop
size
empty
front
back

# deque
## 构造函数
**deque():创建一个空deque**
**deque(int nSize):创建一个deque,元素个数为nSize**
**deque(int nSize,const T& t):创建一个deque,元素个数为nSize,且值均为t**
**deque(const deque &):复制构造函数**

## 增加函数
**void push_front(const T& x):双端队列头部增加一个元素x**
**void push_back(const T& x):双端队列尾部增加一个元素x**

iterator insert(iterator it,const T& x):双端队列中某一元素前增加一个元素x
void insert(iterator it,int n,const T& x):双端队列中某一元素前增加n个相同的元素x
void insert(iterator it,const_iterator first,const_iteratorlast):双端队列中某一元素前插入另一个相同类型向量的[forst,last)间的数据

### 删除函数
Iterator erase(iterator it):删除双端队列中的某一个元素
Iterator erase(iterator first,iterator last):删除双端队列中[first,last）中的元素

**void pop_front():删除双端队列中最前一个元素**
**void pop_back():删除双端队列中最后一个元素**
**void clear():清空双端队列中所有元素**

### 遍历函数
**reference at(int pos):返回pos位置元素的引用**
**reference front():返回首元素的引用**
**reference back():返回尾元素的引用**

iterator begin():返回向量头指针，指向第一个元素
iterator end():返回指向向量中最后一个元素下一个元素的指针（不包含在向量中）
reverse_iterator rbegin():反向迭代器，指向最后一个元素
reverse_iterator rend():反向迭代器，指向第一个元素的前一个元素

### 判断函数
bool empty() const:向量是否为空，若true,则向量中无元素

### 大小函数
**Int size() const:返回向量中元素的个数**
int max_size() const:返回最大可允许的双端对了元素数量值

### 其他函数
void swap(deque&):交换两个同类型向量的数据
void assign(int n,const T& x):向量中第n个元素的值设置为x


# struct
## 初始化函数
```C++
typedef struct Test{
    int id;
    int name;
    // 用以不初始化就构造结构体
    Test(){} ;
    //只初始化id
    Test(int _name) {
        name = _name;
    }
    //同时初始化id,name
    Test(int _id,int _name): id(_id),name(_name){};
}Test;
```

## sizeof 对齐
结构体大小必须是所有成员大小的整数倍，也即所有成员大小的公倍数

Char      偏移量必须为sizeof(char)即1的倍数 
Short     偏移量必须为sizeof(short)即2的倍数 
int       偏移量必须为sizeof(int)即4的倍数 
float     偏移量必须为sizeof(float)即4的倍数 
double    偏移量必须为sizeof(double)即8的倍数 

```C++
struct s1
{
　char a;
　double b;
　int c;
　char d;
};

struct s2
{
　char a;
　char b;
　int c;
　double d;
};

cout<<sizeof(s1)<<endl; // 24
cout<<sizeof(s2)<<endl; // 16
```

# 树
#### 满二叉树
k层有2^k-1个节点 每一层都装满
#### 完全二叉树
k层，除了最后一层每一层都装满，最后一层节点从左往右排布
#### 二叉查找树 Binary Search Tree(BST)
左边节点小于根节点，右边节点大于等于根节点，中序遍历是递增的
#### 平衡查找树 Balanced Search Tree
平衡因子（Balance Factor, BF）：左子树高度与右子树高度之差
使用二叉搜索树对某个元素进行查找，虽然平均情况下的时间复杂度是 O(log n)，但是最坏情况下（当所有元素都在树的一侧时）的时间复杂度是 O(n)。因此有了平衡查找树，平均和最坏情况下的时间复杂度都是 O(log n)
平衡查找树有很多不同的实现方式：AVL 树、2-3查找树、伸展树、红黑树、B树、B+树

##### AVL 树/平衡二叉树（Balanced Binary Tree）
对于所有结点，BF 的绝对值小于等于1，即左、右子树的高度之差的绝对值小于等于1
可支持 O(log n) 的查找、插入、删除，它比红黑树严格意义上**更为平衡**，从而导致**插入和删除更慢**，但**遍历却更快**。
适合用于**只需要构建一次**，就可以在不重新构造的情况下读取的情况。
##### 2-3查找树
##### 伸展树 ？？
##### 红黑树 ？？
##### B树
##### B+树



# 散列表 hash table
## 哈希函数（散列函数）
1. 直接定址法
    Hash(key) = A*key+B。A和B的值任意取，但是不能太大。
    优点：简单，均匀，适合查找比较小且连续的情况。
    缺点：需要事先知道关键字的分步情况
2. 除留余数法
    Hash(key) = key % p (p<=m) 散列表中允许的地址数为m，取质数p(p<=m)作为除数
    优点：冲突较小
    缺点：质数（素数）p的值较难取。
3. 平方取中法    
    关键字平方再取中间的n位作为散列地址(eg.关键字=4321，平方=18671041，取中间的3位=671/710用作散列地址)
    适合：不知道关键字的分布，而位数又不是很大的情况。
4. 折叠法    
    折叠法是将关键字从左到右分割成位数相等的几部分(注意：后一部分位数不够时可以短些)，然后将这几部分叠加求和，并按散列表表长，取后几位作为散列地址。
    eg.关键字=9876543210，散列表表长为3位，我们将它分成四组987|654|321|0|，然后将它们叠加求和987+654+321+0=1962，再求后3位得到散列地址为962。
    适合：事先不需要知道关键字的分布，关键字位数比较多
4. 随机数法     
    H(key) = random(key) 选择一个随机函数，取关键字的随机函数值为它的哈希地址，random为随机数函数
    适合：关键字长度不等时
5. 数学分析法
    设有n个d位数，每一位可能有r种不同的符号，这r种不同的符号在各位上出现的频率不一定相同，可能在某些位上分布比较均匀，每种符号出现的机会均等，在某些位上分布不均匀只有某几种符号经常出现。可根据散列表的大小，选择其中各种符号分布均匀的若干位作为散列地址。
    适合：关键字位数比较大的情况，事先知道关键字的分布且关键字的若干位分布较均匀

总结：构造哈希函数需要注意以下几点：
 1、哈希函数的定义域必须包括需要存储的全部关键码，而如果散列表允许有m个地址时，其值域必须在0到m-1之间
 2、哈希函数计算出来的地址能均匀分布在整个空间中 
 3、哈希函数应该比较简单

## 解决哈希冲突
当散列函数 hash(key) 计算key的存放位置发现这个桶已经被另一个key占据了，即发生哈希冲突。
#### 闭散列法/开地址法
##### 线性探查：
hash(key)+0,hash(key)+1,hash(key)+2, ....  hash(key)+i
冲突时通过顺序扫描数组(可以往回找)，直到找到空的位置。查找算法也使用了探测法
有可能引发**原始集聚**问题，即导致**局部范围大规模发生冲突**。使得寻找某关键码的位置需要多次比较，搜索时间增加。
##### 二次探查
hash(key)+0^2,hash(key)+1^2,hash(key)+2^2, ....  hash(key)+i^2。
二次探测法检查了远离原始探测点的单元，这样的话就降低了原始集聚化问题。

#### 开散列法(链地址法):
数组查找容易，插入删除难，链表插删容易，查找困难，拉链法：可以理解为数组中存放链表，相同关键码放在数据同一下标的链表里。

## hash表扩容
元素个数/hash表长度一般控制在0.7 -0.8，如果超过就要扩容

Hash表中每次发现loadFactor到一定程度时（比如大于0.8），就**开辟一个原来桶数组的两倍空间**（称为新桶数组），然后把原来的桶数组中元素所有转移过来到新的桶数组中。注意这里转移是需要元素**一个个重新哈希到新桶中的**
缺点：容量扩张是**一次完毕**的，期间要花非常长时间一次转移hash表中的全部元素

改进：扩容过程由独立的线程来完成，扩容过程中会采用2个Hash表，将老表中的数据通过Hash算法映射到新表中，每次移动的桶的数目可以配置，默认是每次移动老表中的1个桶。这样的策略就把第一个hash表全部元素的转移分摊为**多次转移**，并且**每次转移的期望时间复杂度为O(1)**。

## 优化/提高效率
### 优化
* 哈希表是静态的，存储的元素数目有限：将哈希表改成**动态存储**的，自行开辟空间，并且实现增容等功能；
* 只能存储整型元素，不具有扩展性：在程序中引入将**字符串转化为整型**的函数，再利用仿函数实现对整型和字符串类型的存储和查找
* 无法判断哈希表的**存储是否满**了等情况：**引入负载因子**，提高哈希表的存储和查找效率；

### 如何提高hash查找的效率
* 设置好的hash函数，冲突尽量少
* 空间换时间，增大表长
* hash桶挂红黑树


# HashMap 和 Hashtable 以及 TreeMap 的区别
## HashMap 和 Hashtable
* 相同点：都实现了Map接口，都是轻量级的实现。两者采用的Hash算法几乎一样，所以性能不会有很大的差异。
* 不同点：
  1. 语法：**HashMap允许键值为空**，Hashtable不允许键值为空。
  2. 安全：
     * **HashMap不支持线程同步，是非线程安全的**
     * HashTable支持线程同步，是线程安全的
     * **HashMap相对来说效率可能会高于Hashtable**

## TreeMap
TreeMap是利用红黑树来实现的，实现了SortMap接口，能够对保存的记录**根据键进行排序**
所以一般需要排序的情况下是选择TreeMap来进行。


# set map unordered_set unordered_map
set和map内部实现是基于RB-Tree，会自行对存储的数据进行排序
unordered_set和unordered_map内部实现是基于哈希表(hashtable)，不会自行对存储的数据进行排序

set：
不以键值对的形式存储数据，而是直接存储数据的值
容器内部存储的各个元素的值都互不相等，且不能被修改。

## map与unordered_map
### 引入头文件不同
map: #include < map >
unordered_map: #include < unordered_map >

### 内部实现机理不同
- map：map内部实现了一个**红黑树**（红黑树是非严格平衡二叉搜索树，而AVL是严格平衡二叉搜索树），红黑树具有自动排序的功能，因此**map内部的所有元素都是有序的**，红黑树的每一个节点都代表着map的一个元素。因此，对于map进行的查找，删除，添加等一系列的操作都相当于是对红黑树进行的操作。map中的元素是按照二叉搜索树（又名二叉查找树、二叉排序树，特点就是左子树上所有节点的键值都小于根节点的键值，右子树所有节点的键值都大于根节点的键值）存储的，使用中序遍历可将键值按照从小到大遍历出来。
- unordered_map: unordered_map内部实现了一个**哈希表**（也叫散列表，通过把关键码值映射到Hash表中一个位置来访问记录，查找的时间复杂度可达到O(1)，其在海量数据处理中有着广泛应用）。因此，其元素的排列顺序是无序的。

### 优缺点以及适用处
- map：
优点：**有序性**，这是map结构最大的优点，其元素的有序性在很多应用中都会简化很多的操作。红黑树，内部实现一个红黑书使得map的很多操作在lgn的时间复杂度下就可以实现，因此**效率非常的高**
缺点：**空间占用率高**，因为map内部实现了红黑树，虽然提高了运行效率，但是因为每一个节点都需要额外保存父节点、孩子节点和红/黑性质，使得每一个节点都占用大量的空间
适用：对于那些**有顺序要求的问题**，用map会更高效一些

- unordered_map：
优点： 因为内部实现了哈希表，因此其**查找速度非常的快**
缺点： 哈希表的**建立比较耗费时间**
适用处：对于**查找问题**，unordered_map会更加高效一些，因此遇到查找问题，常会考虑一下用unordered_map

- 总结：
内存占有率的问题就转化成红黑树 VS hash表 , 还是**unorder_map占用的内存要高**。
但是**unordered_map执行效率**要比map**高**很多

- map和unordered_map的使用
unordered_map的用法和map是一样的，提供了 insert，size，count（计算参数key有几个）等操作，并且里面的元素也是以pair类型来存贮的。其底层实现是完全不同的，但是就外部使用来说却是一致的。

- unordered_map
  - 长度 myMap.size()
  - 下标 myMap[i]="第i个value"
  - 插入 myMap[i]="new value" or maMap.insert(pair(key,value))

# 红黑树
1. 它是二叉排序树（继承二叉排序树特显）：
    * 若左子树不空，则左子树上所有结点的值均小于或等于它的根结点的值。
    * 若右子树不空，则右子树上所有结点的值均大于或等于它的根结点的值。
    * 左、右子树也分别为二叉排序树。
2. **它满足如下几点要求：**
    * 树中所有节点非红即黑。
    * 根节点必为黑节点。
    * 红节点的子节点必为黑（黑节点子节点可为黑）。
    * 从根到NULL的任何路径上黑结点数相同。
3. 查找时间一定可以控制在O(logn)。

# 海量数据处理：如何从10亿个数中，找出最大的10000个数？（top K问题）
## 1. 局部淘汰法
该方法与排序方法类似，用一个容器保存前10000个数，然后将剩余的所有数字——与容器内的最小数字相比，如果所有后续的元素都比容器内的10000个数还小，那么容器内这个10000个数就是最大10000个数。如果某一后续元素比容器内最小数字大，则删掉容器内最小元素，并将该元素插入容器，最后遍历完这1亿个数，得到的结果容器中保存的数即为最终结果了。此时的时间复杂度为O（n+m^2），其中m为容器的大小，即10000。

## 2. 分治法
将1亿个数据分成100份，每份100万个数据，找到每份数据中最大的10000个，最后在剩下的 100 * 10000 个数据里面找出最大的10000个。如果100万数据选择足够理想，那么可以过滤掉1亿数据里面99%的数据。100万个数据里面查找最大的10000个数据的方法如下：
用快速排序的方法，将数据分为2堆，如果大的那堆个数N大于10000个，继续对大堆快速排序一次分成2堆，如果大的那堆个数N大于10000个，继续对大堆快速排序一次分成2堆，如果大堆个数N小于10000个，就在小的那堆里面快速排序一次，找第10000-n大的数字；递归以上过程，就可以找到第1w大的数。。此种方法需要每次的内存空间为10^6*4=4MB，一共需要101次这样的比较。

## 3. Hash 法
如果这1亿个书里面有很多重复的数，先通过Hash法，把这1亿个数字去重复，这样如果重复率很高的话，会减少很大的内存用量，从而缩小运算空间，然后通过分治法或最小堆法查找最大的10000个数。

## 4. 最小堆
首先读入前10000个数来创建大小为10000的最小堆，建堆的时间复杂度为O（mlogm）（m为数组的大小即为10000），然后遍历后续的数字，并于堆顶（最小）数字进行比较。如果比最小的数小，则继续读取后续数字；如果比堆顶数字大，则替换堆顶元素并重新调整堆为最小堆。整个过程直至1亿个数全部遍历完为止。然后按照中序遍历的方式输出当前堆中的所有10000个数字。该算法的时间复杂度为O（nmlogm），空间复杂度是10000（常数）。


# 并查集
https://blog.csdn.net/dm_vincent/article/details/7655764